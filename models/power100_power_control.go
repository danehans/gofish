package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/validate"
)

// Power100PowerControl This is the base type for addressable members of an array.
// swagger:model Power.1.0.0_PowerControl
type Power100PowerControl struct {

	// This is the identifier for the member within the collection.
	MemberID string `json:"MemberId,omitempty"`

	// Power Control Function name.
	// Read Only: true
	Name string `json:"Name,omitempty"`

	// This is the manufacturer/provider specific extension moniker used to divide the Oem object into sections.
	Oem ResourceOem `json:"Oem,omitempty"`

	// The total amount of power that has been allocated (or budegeted)to  chassis resources.
	// Read Only: true
	// Minimum: 0
	PowerAllocatedWatts float64 `json:"PowerAllocatedWatts,omitempty"`

	// The amount of power not already budgeted and therefore available for additional allocation. (powerCapacity - powerAllocated).  This indicates how much reserve power capacity is left.
	// Read Only: true
	// Minimum: 0
	PowerAvailableWatts float64 `json:"PowerAvailableWatts,omitempty"`

	// The total amount of power available to the chassis for allocation. This may the power supply capacity, or power budget assigned to the chassis from an up-stream chassis.
	// Read Only: true
	// Minimum: 0
	PowerCapacityWatts float64 `json:"PowerCapacityWatts,omitempty"`

	// The actual power being consumed by the chassis.
	// Read Only: true
	// Minimum: 0
	PowerConsumedWatts float64 `json:"PowerConsumedWatts,omitempty"`

	// Power limit status and configuration information for this chassis
	PowerLimit *Power100PowerLimit `json:"PowerLimit,omitempty"`

	// Power readings for this chassis.
	PowerMetrics *Power100PowerMetric `json:"PowerMetrics,omitempty"`

	// The potential power that the chassis resources are requesting which may be higher than the current level being consumed since requested power includes budget that the chassis resource wants for future use.
	// Read Only: true
	// Minimum: 0
	PowerRequestedWatts float64 `json:"PowerRequestedWatts,omitempty"`

	// The ID(s) of the resources associated with this Power Limit
	RelatedItem []*Odata400IDRef `json:"RelatedItem"`

	// related item at odata count
	// Read Only: true
	RelatedItemAtOdataCount float64 `json:"RelatedItem@odata.count,omitempty"`

	// related item at odata navigation link
	RelatedItemAtOdataNavigationLink *Odata400IDRef `json:"RelatedItem@odata.navigationLink,omitempty"`

	// status
	Status *ResourceStatus `json:"Status,omitempty"`
}

// Validate validates this power 1 0 0 power control
func (m *Power100PowerControl) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePowerAllocatedWatts(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePowerAvailableWatts(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePowerCapacityWatts(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePowerConsumedWatts(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePowerLimit(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePowerMetrics(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePowerRequestedWatts(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRelatedItem(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRelatedItemAtOdataNavigationLink(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Power100PowerControl) validatePowerAllocatedWatts(formats strfmt.Registry) error {

	if swag.IsZero(m.PowerAllocatedWatts) { // not required
		return nil
	}

	if err := validate.Minimum("PowerAllocatedWatts", "body", float64(m.PowerAllocatedWatts), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Power100PowerControl) validatePowerAvailableWatts(formats strfmt.Registry) error {

	if swag.IsZero(m.PowerAvailableWatts) { // not required
		return nil
	}

	if err := validate.Minimum("PowerAvailableWatts", "body", float64(m.PowerAvailableWatts), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Power100PowerControl) validatePowerCapacityWatts(formats strfmt.Registry) error {

	if swag.IsZero(m.PowerCapacityWatts) { // not required
		return nil
	}

	if err := validate.Minimum("PowerCapacityWatts", "body", float64(m.PowerCapacityWatts), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Power100PowerControl) validatePowerConsumedWatts(formats strfmt.Registry) error {

	if swag.IsZero(m.PowerConsumedWatts) { // not required
		return nil
	}

	if err := validate.Minimum("PowerConsumedWatts", "body", float64(m.PowerConsumedWatts), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Power100PowerControl) validatePowerLimit(formats strfmt.Registry) error {

	if swag.IsZero(m.PowerLimit) { // not required
		return nil
	}

	if m.PowerLimit != nil {

		if err := m.PowerLimit.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *Power100PowerControl) validatePowerMetrics(formats strfmt.Registry) error {

	if swag.IsZero(m.PowerMetrics) { // not required
		return nil
	}

	if m.PowerMetrics != nil {

		if err := m.PowerMetrics.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *Power100PowerControl) validatePowerRequestedWatts(formats strfmt.Registry) error {

	if swag.IsZero(m.PowerRequestedWatts) { // not required
		return nil
	}

	if err := validate.Minimum("PowerRequestedWatts", "body", float64(m.PowerRequestedWatts), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Power100PowerControl) validateRelatedItem(formats strfmt.Registry) error {

	if swag.IsZero(m.RelatedItem) { // not required
		return nil
	}

	for i := 0; i < len(m.RelatedItem); i++ {

		if swag.IsZero(m.RelatedItem[i]) { // not required
			continue
		}

		if m.RelatedItem[i] != nil {

			if err := m.RelatedItem[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *Power100PowerControl) validateRelatedItemAtOdataNavigationLink(formats strfmt.Registry) error {

	if swag.IsZero(m.RelatedItemAtOdataNavigationLink) { // not required
		return nil
	}

	if m.RelatedItemAtOdataNavigationLink != nil {

		if err := m.RelatedItemAtOdataNavigationLink.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *Power100PowerControl) validateStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.Status) { // not required
		return nil
	}

	if m.Status != nil {

		if err := m.Status.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}
